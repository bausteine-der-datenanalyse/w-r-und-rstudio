{
  "hash": "715f6db992ca6a27d0f55dba42229001",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Räumliche Daten\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n# Einführung\n\n## Räumliche Daten\n\n![GIS Layers](bilder/GISLayers.png) [Quelle: http//landportal.org]{.imagesource}\n\n-   Viele Daten haben räumlichen Bezug\n-   Klassische Anwendung von Geoinformationssystemen (GIS)\n    -   Programme: ArcGIS (kommerziell) und QGIS (Open Source)\n-   Verarbeitung räumlicher Daten schon seit langem auch in R\n-   Gute Integration in ggplot2: [Paket sf](https://r-spatial.github.io/sf/) (simple feature)\n\n## Geographische Daten: Einzelne Punkte {.smaller}\n\n![](bilder/koordinaten.svg)\n\n**Koordinatensystem mit Breiten- und Längengraden**\n\n- Koordinaten eines Punktes mit Breitengrad (*latitute*) und Längengrad (*longitude*) \n  - Angaben im Winkelmaß\n  - Breitengrad ab Äquator (zwischen -90° und 90° oder mit Zusatz N/S)\n  - Längengrad ab Nullmeridian (zwischen -180° und 180° oder mit Zusatz O/W)\n- Schreibweise manchmal im Sexagesimalsystem (Winkelminuten und Sekunden)\n  - Koordinaten des Gipfels der Zugspitze: 47°25′16″N, 010°59′7″O\n- Die Erde ist keine Kugel\n  - Referenzellipsoid, häufig World Geodetic System 1984 (WGS 84)\n\n## GPS-Koordinaten Hochschule Bochum\n\n![](bilder/gps.jpg)\n\n- Etwas oberhalb vom 50. Breitengrad und etwas östlich vom 7. Längengrad\n\n## Mercator-Projektion 1/2\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n- Breiten- und Längengrad in kartesischem Koordinatensystem\n- Problem: Länder am Äquator zu klein (oder umgekehrt)\n\n## Mercator-Projektion 2/2\n\n[![](bilder/mercator-projektion-film.png)](https://commons.wikimedia.org/wiki/File:Die_Weltkarte_von_Mercator.webm)\n[Bild ist Link zum Film]{.imagesource}\n\n## Robinson-Projektion\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n- Breiten- und Längengrad in gekrümmtem Koordinatensystem aufgetragen\n- Keine Projektion im mathematischen Sinne\n\n## Lambertsche Azimutalprojektion\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n- Flächen werden korrekt abgebildet\n- Weder winkel- noch längentreu\n\n## Geographische Daten: Geometrien\n\n![](bilder/sf-classes.svg)\n\n**Simple Features**\n\n- Offener Standard für geometrische Daten (ISO 19125-1:2004)\n- Entwickelt vom *Open Geospatial Consortium* (OGC)\n- Grundlage für viele GIS-Programme\n\n## R-Paket sf (Simple Features for R)\n\n![](bilder/simple-feature.png)\n\n**Paket sf: Simple Features in Dataframes**\n\n- Beispiel oben: Dataframe der Weltkarte (Ausschnitt)\n- Ganz normaler Dataframe mit Spalten\n  - `ISO3` (Ländercode)\n  - `geometry` (Geometrie eines Landes als Simple Feature)\n- Kann mit ggplot2 geplottet werden\n- Mehr Informationen [hier](https://rstudio.com/resources/rstudioconf-2018/tidy-spatial-data-analysis)\n\n# Weltkarte mit Natural Earth\n\n## Daten: Die Welt als Dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_world <- ne_countries(returnclass = \"sf\") |>\n  select(admin, adm0_a3, geometry) |>\n  filter(adm0_a3 != \"ATA\")\n```\n:::\n\n\n- Weltkarte mit `ne_countries()` [weitere Infos hier](http://www.naturalearthdata.com) als `sf`-Objekt\n- Benötigte Spalten mit `select()` auswählen\n  - ISO3-Codes der Länder (eindeutig)\n  - Geometrie\n- Die Antarktis interessiert uns nicht\n\n## Plot der Weltkarte\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = d_world)\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n- Plotten von `sf` Dataframes mit `geom_sf()` \n- Mapping für Geometrie ist eingebaut\n\n# Berechnung neuer Daten\n\n## Weltkarte mit Fläche der Länder 1/2 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_world_a <- d_world |>\n  mutate(area = as.numeric(st_area(geometry)) * 1e-6)\n```\n:::\n\n\n![Welt mit Fläche](bilder/simple-feature-area-2.png)\n\n- Berechnung der Flächen mit `st_area()`\n- Alle Funktionen im `sf`-Paket beginnen mit `st_` (man muss nicht alles verstehen)\n- Einheiten entfernen mit `as.numeric()` und in Quadratkilometern\n- Fläche Argentinien laut Wikipedia: 2.780.400 km<sup>2</sup> (Vermutung: Karte nicht sehr genau)\n\n## Weltkarte mit Fläche der Länder 2/2 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = d_world_a) + \n  geom_sf(mapping = aes(fill = area)) +\n  scale_fill_distiller(palette = 8, direction = 1)\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n→ Eine solche Karte heißt Choroplethenkarte (auch Flächenkartogramm oder Flächenwertstufenkarte)\n\n# Kombination mit anderen Daten\n\n## Weltkarte mit der Lebenswerwartung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_le <- wb_data(indicator = \"SP.DYN.LE00.IN\") |>\n  select(adm0_a3 = iso3c, date, le = SP.DYN.LE00.IN) |>\n  filter(!is.na(le)) |> \n  group_by(adm0_a3) |> \n  slice_max(date)\n```\n:::\n\n\n- Dataframe zu Weltbankindikatoren mit `wb_data()` (Paket `wbstats`) herunterladen\n  - Indikator [hier] (https://data.worldbank.org heraussuchen) (Details)\n- Wichtige Merkmale auswählen und passend umbenennen\n- Für jedes Land den neuesten Wert heraussuchen\n\n## Dataframes miteinander verknüpfen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_world_le <- d_world |>\n  left_join(d_le, by = \"adm0_a3\")\n```\n:::\n\n\n- Funktioniert, weil beide Dataframes eine Variable `adm0_a3` haben\n- Natürlich nicht nur mit Daten von der Weltbank\n\n## Weltkarte mit Lebenserwartung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = d_world_le) + \n  geom_sf(mapping = aes(fill = le)) +\n  scale_fill_distiller(palette=\"RdPu\") \n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n# Werte zu einzelnen Koordinaten plotten\n\n## Erste Möglichkeit: Mit `geom_point` {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_cities <- read_xlsx(\"daten/cities.xlsx\")\nggplot() + geom_sf(data = d_world) +\n  geom_point(data = d_cities, mapping = aes(x = long, y = lat, size = pop), color = \"hotpink\", show.legend = FALSE)\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n- Geodaten zu Punkten mit Breitengrad und Längengrad\n- Darstellen mit `geom_point()` wie gehabt\n- Dataframe als Parameter zu geom\n- Klappt so einfach nur mit Mercator-Projektion\n\n## Besser: Dataframe konvertieren und `geom_sf` {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_cities_sf <- d_cities |> st_as_sf(coords = c(\"long\", \"lat\"), crs = \"+proj=longlat\")\nggplot() + geom_sf(data = d_world) +\n  geom_sf(data = d_cities_sf, mapping = aes(size = pop), color = 'hotpink', show.legend = FALSE)\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n- Dataframe in Simple Feature Objekt konvertieren mit `st_as_sf`\n  - Mit `coords` angeben in welchen Spalten die Koordinaten stehen\n  - Referenzkoordinatensystem angeben\n- Plotten mit `geom_sf`\n\n# Landesgrenzen mit `giscoR`\n\n## Landesgrenzen 1/2 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_de <- gisco_get_nuts(country = \"Germany\", nuts_level = 0, resolution = 03)\nd_bl <- gisco_get_nuts(country = \"Germany\", nuts_level = 2, resolution = 03)\nd_rb <- gisco_get_nuts(country = \"Germany\", nuts_level = 3, resolution = 03)\n```\n:::\n\n\n- GISCO: Geografisches Informationssystem der EU-Kommission\n- Paket [`giscoR`](https://ropengov.github.io/giscoR/) (R-Schnittstelle zu Daten der EU)\n- Datensatz laden mit `gisco_get_nuts`\n  - `country` Land\n  - `nuts_level` gibt Ebene an (Staat/Bundesländer/Regierungsbezirke)\n  - `resolution` Auflösung, siehe Dokumentation\n  - [NUTS](https://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics) ist ein System zur Bezeichnung von Ländern\n\n## Landesgrenzen 2/2 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = d_rb, mapping = aes(fill = NUTS_NAME), linewidth = 0.1, show.legend = FALSE) +\n  geom_sf(data = d_bl, fill = NA, linewidth = 0.5, color = 'white') +\n  geom_sf(data = d_de, fill = NA, linewidth = 0.75, color='black') +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n# Open Street Map\n\n## Über Open Street Map\n\n![](bilder/osm.svg)\n\n- Freie Alternative zu Google Maps\n- Zugriff auf Daten aus eigenen Programmen\n- SEHR umfangreich aber nicht ganz einfach zu nutzen\n- In R mit Paket `osmdata` (https://github.com/ropensci/osmdata)\n\n## Straßen in Bochum 1/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# q <- opq(getbb('Bochum, Germany'))\n# s1 <- add_osm_feature(q, key = \"highway\", value = \"motorway\") |> osmdata_sf()\n```\n:::\n\n\n- Bereich festlegen mit `getbb` (bb steht für Bounding Box)\n- Anfrage `q` erzeugen mit `opq`\n- Objekte zu Anfrage hinzufügen mit `add_osm_feature`\n  - `key` ist die Kategorie\n  - `value` sagt was genau gemeint ist\n  - https://wiki.openstreetmap.org/wiki/Map_features\n- Mit `osmdata_sf` zur Verwendung mit SF aufbereiten\n  - Objekt enthält `osm_points`, `osm_lines`, `osm_polygons`, ...\n  - Dies sind die eigentlichen SF-Objekte\n\n## Straßen in Bochum 2/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ggplot() + \n#   geom_sf(data = s1$osm_lines)\n```\n:::\n\n\n- Mit `$osm_lines` die Linien heraussuchen\n\n## Karte von Bochum 1/3\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if (!file.exists(\"daten/strassen-bochum.RData\")) {\n#   q  <- opq(getbb('Bochum, Germany'), timeout = 600)\n#   s1 <- add_osm_feature(q, key = \"highway\", value = c(\"motorway\", \"primary\", \"motorway_link\", \"primary_link\")) |> osmdata_sf()\n#   s2 <- add_osm_feature(q, key = \"highway\", value = c(\"secondary\", \"tertiary\", \"secondary_link\", \"tertiary_link\")) |> osmdata_sf()\n#   s3 <- add_osm_feature(q, key = \"highway\", value = c(\"unclassified\", \"residential\")) |> osmdata_sf()\n#   f1 <- add_osm_feature(q, key = \"waterway\", value = \"river\") |> osmdata_sf()\n#   u1 <- add_osm_feature(q, key = \"amenity\", value = \"university\") |> osmdata_sf()\n# save(s1, s2, s3, f1, u1, file = \"daten/strassen-bochum.RData\")\n# } else {\n#   load(file = \"daten/strassen-bochum.RData\")\n# }\n```\n:::\n\n\n- Mit `c` mehrere Objekte aus einer Kategorie kombinieren\n- Daten teilweise recht umfangreich, Download kann dauern oder auch zu Abbrüchen oder Fehlermeldungen führen\n- Daher: Daten einmal herunterladen, auf Festplatte speichern und ab dann nur noch einlesen\n\n## Karte von Bochum 2/3\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# p <- ggplot() + \n#   geom_sf(data = u1$osm_polygons, color = 'orange', linewidth = 0.35) +\n#   geom_sf(data = f1$osm_lines, color = 'steelblue', linewidth = 0.35) +\n#   geom_sf(data = s3$osm_lines, color = 'light gray', linewidth = 0.15) +\n#   geom_sf(data = s2$osm_lines, color = 'dark gray', linewidth = 0.25) +\n#   geom_sf(data = s1$osm_lines, color = 'black', linewidth = 0.35) +\n#   coord_sf(xlim = c(7.1, 7.3), ylim = c(51.41, 51.52)) +\n#   theme_void()\n```\n:::\n\n\n- Plot in Variable `p` speichern und auf nächster Folie ausgeben\n\n## Karte von Bochum 3/3\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# p\n```\n:::\n\n\n## Bundesautobahnen 1/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!file.exists(\"daten/bab.RData\")) {\n  q <- opq(bbox = getbb(\"Deutschland\", featuretype = \"country\"), timeout = 600)\n  d_bab_raw <- (add_osm_feature(q, key = \"highway\", value = \"motorway\") |> osmdata_sf())$osm_lines\n  d_bab <- d_bab_raw |>\n    filter(st_contains(d_de, d_bab_raw, sparse = FALSE)[1,]) |>\n    drop_na(ref) |>\n    group_by(ref) |>\n    summarise() |>\n    st_simplify(dTolerance = 100) \n  save(d_bab, d_bab_raw, file = \"daten/bab.RData\")\n} else {\n  load(file = \"daten/bab.RData\")\n}\n```\n:::\n\n\n- Daten einmal herunterladen, aufbereiten und speichern, dann nur noch einlesen\n- Aufbereiten der Daten nicht trivial (zusammenfügen, auswählen und vereinfachen)\n- siehe auch [GitHub](https://github.com/spiegel-daten/2019-02-tempolimit) \n\n## Bundesautobahnen 2/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = d_bl, linewidth = 0.25) + \n  geom_sf(data = d_de, fill = NA, linewidth = 0.5) +\n  geom_sf(data = d_bab, mapping = aes(color = ref), linewidth = 0.35, show.legend = FALSE) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n- Zeichnen zusammen mit Karte\n\n## Ausschnitt festlegen: Möglichkeit 1/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# q <- opq(getbb('Bochum, Germany'))\n# s1 <-  add_osm_feature(q, key = \"highway\", value = \"motorway\") |> osmdata_sf()\n# ggplot() + geom_sf(data = s1$osm_lines) + coord_sf(xlim = c(7.1, 7.3), ylim = c(51.41, 51.52))\n```\n:::\n\n\n- Ausschnitt mit `coord_sf` festlegen\n\n## Ausschnitt festlegen: Möglichkeit 2/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# q <- opq(c(7.1, 51.41, 7.3, 51.52))\n# s1 <- add_osm_feature(q, key = \"highway\", value = \"motorway\") |> osmdata_sf()\n# ggplot() + geom_sf(data = s1$osm_lines)\n```\n:::\n\n\n- Ausschnitt der Anfrage bei `opq` angeben (und nicht mittels `getbb`)\n\n## Weitere hilfreiche Quelle zu OSM\n\n- [OpenStreetMap Wiki] (https://wiki.openstreetmap.org/wiki/Map_features)\n\n# Shapefiles\n\n## Shapefiles {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_wkr <- st_read(\"daten/Wkr_25833.shp\", quiet = TRUE) |> st_transform(crs = \"+proj=longlat\")\nggplot(data = d_wkr) + geom_sf(mapping = aes(fill = Wkr), show.legend = FALSE)\n```\n\n::: {.cell-output-display}\n![](räumliche-daten_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n- Dateiformat Shapefile (Endung .shp): Ursprünglich für ArcView (ESRI) entwickeltes Format für vektorielle Geodaten\n- Einlesen in R mit `st_read()`\n- [Quelle] (https://daten.berlin.de/datensaetze/geometrien-der-wahlkreise-für-die-abgeordnetenhauswahl-berlin-2016)\n\n",
    "supporting": [
      "räumliche-daten_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}