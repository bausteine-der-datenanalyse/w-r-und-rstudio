{
  "hash": "c879f30e9e22720387b30bf42fe2a223",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Basics der Programmiersprache R\"\nsubtitle: \"Kurz und (fast) schmerzlos\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n# Operatoren und grundlegende Funktionen\n\n## Arithmetische Operatoren\n\n[]{.down80}\n\n| Operator | Beschreibung   | Beispiel          |\n|:--------:|:---------------|:------------------|\n|   `+`    | Addieren       | 4 + 5 = 9         |\n|   `-`    | Subtrahieren   | 5 - 4 = 1         |\n|   `*`    | Multiplizieren | 4 \\* 4 = 16       |\n|   `/`    | Dividieren     | 1 / 2 = 0.5       |\n|   `^`    | Potenzieren    | 2\\^0.5 = 1.414214 |\n|   `%%`   | Modulo bilden  | 7 %% 5 = 2        |\n\n- Modulo bilden = Bestimmung des Rests einer ganzzahligen Devision\n\n## Beispiel\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\n1e5 / 33\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3030.303\n```\n\n\n:::\n\n```{.r .cell-code}\npi %% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1415927\n```\n\n\n:::\n\n```{.r .cell-code}\n1 / 3 + 1 / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8333333\n```\n\n\n:::\n\n```{.r .cell-code}\n6^8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1679616\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=50%}\n- Werte werden ohne spezielle print-Anweisung ausgegeben\n- Standardmäßig werden Fließkommaoperationen durchgeführt\n- Lassen Sie Platz um die Operatoren (außer um \\^)\n:::\n:::\n\n## Variablen 1/2\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 32\ny <- 7 / 8\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=50%}\n- Daten und Berechnungsergebnisse werden in Variablen gespeichert\n- Der Zuweisungsoperator in R ist `<-` (Tastenkombination alt + -)\n- Variablen im *Environment* gelistet (RStudio oben rechts)\n- Namen von Variablen müssen mit einem Buchstaben beginnen\n:::\n:::\n\n\n\n\n## Variablen 2/2\n\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- pi\nx <- 2\na.b <- 100\nx * X * a.b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 628.3185\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=50%}\n- `pi` ist eine vorbelegte Variable mit Näherung für $\\pi$\n- Groß- und Kleinschreibung wird berücksichtigt\n- Der Punkt ist ein ganz normaler Buchstabe und kein Operator\n:::\n:::\n\n\n\n## Weitere Zuweisungsoperatoren\n\nZuweisung nach rechts\n\n\n::: {.cell}\n\n```{.r .cell-code}\n33 -> x\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 33\n```\n\n\n:::\n:::\n\n\n- Die Schreibweise `<-` funktioniert auch so `->` rum\n\n[]{.down40}\n\nEs geht aber auch traditionell\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 200\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 200\n```\n\n\n:::\n:::\n\n\n- Wenn Ihnen das lieber ist, verwenden Sie `=`\n- Bei einer Schreibweise bleiben\n\n## Primitive Datentypen\n\n[]{.down40}\n\n| Datentyp  | Literale             |\n|-----------|----------------------|\n| logical   | `TRUE`, `FALSE`      |\n| integer   | `5L`, `125L`         |\n| double    | `1`, `1.75`, `1e10`  |\n| character | `\"Hello World!\"`     |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n[]{.down40}\n\n- Datentypen werden nicht explizit angegeben (anders als in Java)\n- Voreinstellung für Zahlen ist `double`\n- Anderen Programmiersprachen: String statt Character\n- logical = Wahrheitswerte\n- integer = ganzzahlig\n- character = Zeichenkette\n\n## Spezielle Konstanten\n\n[]{.down80}\n\n| Konstante        | Bedeutung                                           |\n|------------------|-----------------------------------------------------|\n| `Inf` und `-Inf` | Unendlich und minus Unendlich                       |\n| `NaN`            | Rechenoperation ergibt keine Zahl, z.B. $\\sqrt{-1}$ |\n| `NULL`           | Ein leeres Objekt                                   |\n| `NA`             | Unbekannter Datenwert (Not Available)               |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n## Mathematische Funktion\n\n[]{.down20}\n\n| Funktionen                        | Beschreibung                                    |\n|-----------------------------------|-------------------------------------------------|\n| `sin(x)`, `cos(x)`, `tan(x)`, ... | Trigonometrische Funktionen                     |\n| `abs(x)`, `sqrt(x)`               | Absolutwert, Wurzel                             |\n| `log(x)`, `exp(x)`                | Natürlicher Logarithmus und Exponentialfunktion |\n| `log2(x)`, `log10(x)`             | Logarithmus mit anderen Basen                   |\n\n: {tbl-colwidths=\"[40,60]\"}\n\nBeispiele\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.718282\n```\n\n\n:::\n\n```{.r .cell-code}\nlog2(4096)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n## Funktionen zur Typumwandlung\n\n[]{.down100}\n\n| Funktion          | Bedeutung                        |\n|-------------------|----------------------------------|\n| `as.numeric(x)`   | Konvertiert in eine Zahl         |\n| `as.character(x)` | Konvertiert in eine Zeichenkette |\n| `as.logical(x)`   | In Wahrheitswert konvertieren    |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n- as.logical: alle Zahlenwerte = 0 sind FALSE, alle Zahlenwerte ungleich 0 sind TRUE\n\n## Beispiele\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 * as.numeric(\"1.81\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.43\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3.14159265358979\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Vergleichsoperatoren und Verknüpfungen\n[]{.down40}\n\n|    Operator        |           Bedeutung           |\n|--------------------|-------------------------------|\n| `a < b`, `a <= b`  |  Kleiner und kleiner gleich   |\n| `a > b`, `a >= b`  |   Größer und größer gleich    |\n| `a == b`, `a != b` | Exakt gleich und nicht gleich |\n|   `near(a, b)`     |          Fast gleich          |\n|    `is.na(x)`      |    Test of `x` gleich `NA`    |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n[]{.down40}\n\n| Verknüpfung   |   Bedeutung    |\n|-----------|----------------|\n|  `a & b`  | Logisches und  |\n|  `a | b`  | Logisches oder |\n|    `!a`   |    Negation    |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n## Beispiele {.smaller}\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nNA == 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\npi >= 3.14\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\npi != 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(3 * 9 + 1) == 28\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Rechengenauigkeit\n\nAchtung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 / 49 * 49 == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n$\\rightarrow$ Rundungsfehler, Computer rechnet mit (grob gesagt) 15 Nachkommastellen \n\nÜberprüfung in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnear(sqrt(2)^2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nnear(1/49*49, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Weitere nützliche Funktionen 1/2\n\n[]{.down80}\n\n| Funktion                | Beschreibung                                |\n|-------------------------|---------------------------------------------|\n| `paste0(...)`           | Verbindet mehrere Werte zu Character        |\n| `paste(..., sep = \" \")` | Wie paste0 aber mit Trennzeichen            |\n| `signif(x, digits = 6)` | Rundet auf Anzahl von signifikanten Stellen |\n| `round(x, digits = 0)`  | Runden auf Anzahl von Stellen               |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n\n## Weitere nützliche Funktionen 2/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(1, 2, 3, 4, 5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 2 3 4 5 6\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(1, 2, 3, 4, 5, 6, sep = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1, 2, 3, 4, 5, 6\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(1, 2, 3, 4, 5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"123456\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsignif(9283649, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9284000\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(\"pi=\", round(pi, digits = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pi=3.1416\"\n```\n\n\n:::\n:::\n\n\n## Optionale Parameter von Funktionen\n\n```{.r}\nround(x, digits = 0)\n```\n\nFunktion `round` besitzt Parameter `x` (die Zahl die gerundet werden soll) und einen optionalen\nParameter `digits` (Anzahl der Stellen). Wird `digits` nicht angegeben, dann verwendet R den Wert 0.\nBeim Funktionsaufruf kann man den Namen des Parameters weglassen (kürzer) oder angeben (meist besser\nzu verstehen).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nround(pi, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.1\n```\n\n\n:::\n\n```{.r .cell-code}\nround(pi, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14\n```\n\n\n:::\n:::\n\n\n## Funktionen mit vielen Parametern\n\n```{.r}\n`paste(..., sep = \" \")\n```\n\nDer Funktion `paste` können beliebig viele Parameter übergeben werden. Der Name des optionalen\nParameters muss angegeben werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 2 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(1, 2, 3, 4, 5, 6, \"$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 2 3 4 5 6 $\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(1, 2, 3, 4, 5, 6, sep = \"$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1$2$3$4$5$6\"\n```\n\n\n:::\n:::\n\n\n## Hilfe zu R-Funktionen\n\n![](bilder/r-hilfe.svg)\n\n- In RStudio in den Funktionsnamen klicken und Taste F1 drücken\n  - Hilfetexte in der Regel nicht ganz einfach zu lesen\n  - Oft werden verwandte Funktionen gemeinsam erklärt\n  - Das fällt Ihnen mit der Zeit leichter\n\n## Richtig googeln und richtige Verwendung von KI\n\n![](bilder/google.svg)\n\n- Auf Google mit Suchanfragen der Form \"r Suchphrase\"\n- Problem: Häufig zu viele Antworten oder die falsche Information\n- Erst denken, dann googeln, dann nochmal denken\n- Nichts aus dem Internet abtippen, das Sie nicht verstehen\n- Meistens ist .org besser als .com\n- Hinweis wie mit KI/LLMs umgegangen wird\n\n# Datenstrukturen\n\n## Datenstrukturen in R\n\n[]{.up60}\n\n![](bilder/datenstrukturen.svg)\n\n| Datenstruktur | Beschreibung                                         |\n|---------------|------------------------------------------------------|\n| **Vektor**    | Reihe von Elementen mit gleichem Datentyp            |\n| Matrix        | Wie Vektor aber mit Zeilen und Spalten               |\n| Array         | Wie Matrix aber beliebig viele Indizes               |\n| List          | Wie Vektor aber verschiedene Datentypen              |\n| **Dataframe** | Liste, jedes Element ein Vektor, Spalten haben Namen |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n→ Dataframe = Datensatz einer Erhebung\n\n## Vektoren\n\nFür uns wichtig\n\n- Vektoren als Eingabewerte (zum Beispiel beim Plotten)\n- Rechenoperationen für Vektoren (Mittelwert etc.)\n\n→ Hier nur die Dinge, die wir auch benötigen\n\n## Erzeugen von Vektoren 1/2\n\n[]{.down40}\n\n| Funktion                    | Beschreibung                                             |\n|-----------------------------|----------------------------------------------------------|\n| `a:b`                       | Erzeugt einen Vektor von `a` bis `b` mit Inkrement 1        |\n| `c(x1, x2, x3)`             | Erzeugt einen Vektor mit den Werten `x1`, `x2`, `x3`        |\n| `seq(a, b, by = inc)`       | Erzeugt einen Vektor von `a` bis `b` mit Inkrement `inc`    |\n| `seq(a, b, length.out = n)` | Erzeugt einen Vektor von `a` bis `b` mit `n` Elementen      |\n| `rep(x, times = n)`         | Hängt das Array oder die Zahl `x` `n`-mal hintereinander |\n| `rep(x, each = n)`          | Wiederholt jedes Element in `x` `n`-mal                  |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n\n\n[]{.down20}\n\n- `a:b` wie in Matlab (aber kein 1:0.1:2)\n- c steht für *combine*\n- Inkrement = Zunahme\n- seq wie Sequenz\n- rep wie repetition = Wiederholung\n\n\n## Erzeugen von Vektoren 2/2 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:-6                            # Geht auch rückwärts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  0 -1 -2 -3 -4 -5 -6\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"A\", \"B\", \"C\", 1:3)           # Typkonvertierung automatisch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\" \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(1, 5, by = 0.7)             # Zweiter Wert nicht unbedingt dabei\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 1.7 2.4 3.1 3.8 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(1, 5, length.out = 6)       # Inkrement automatisch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 1.8 2.6 3.4 4.2 5.0\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(4, 7, 1, 1), times = 3)   # Drei mal hintereinander\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4 7 1 1 4 7 1 1 4 7 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(4, 7, 1, 1), each = 3)    # Jedes Element drei mal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4 4 4 7 7 7 1 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\n## Operatoren & Funktionen für Vektoren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\ny <- 5:1\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 6 6 6 6\n```\n\n\n:::\n\n```{.r .cell-code}\n1 + x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 8 9 8 5\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n```\n\n\n:::\n:::\n\n\n→ Ausführung Elementweise\n\n## Kuriositätenkabinett {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 0:8\nb <- c(1, 11)\nc <- 99\n```\n:::\n\n\nDamit\n\n\n::: {.cell}\n\n```{.r .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in a + b: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 12  3 14  5 16  7 18  9\n```\n\n\n:::\n\n```{.r .cell-code}\na %% 2 == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na[a %% 3 == 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nc[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 99\n```\n\n\n:::\n:::\n\n\n## Funktionen für Vektoren 1/2\n\n[]{.down80}\n\n| Funktion            | Bedeutung                                |\n|---------------------|------------------------------------------|\n| `c(a, b, ...)`      | Vektor erzeugen (geht auch mit Vektoren) |\n| `length(a)`         | Länge eines Vektors                      |\n| `sum(a)`, `prod(a)` | Summe oder Produkt der Elemente          |\n| `rev(a)`            | Reihenfolge umdrehen                     |\n| `unique(a)`         | Unterschiedliche Elemente                |\n| `a %in% b`          | Ist Wert `a` in Vektor `b` enthalten?    |\n\n: {tbl-colwidths=\"[40,60]\"}\n\n## Funktionen für Vektoren 2/2\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- rep(1:3, 2)\n```\n:::\n\n\n::: {.columns}\n::: {.column}\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nc(a, c(5, 19))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  3  1  2  3  5 19\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n:::\n::: {.column}\n\n::: {.cell}\n\n```{.r .cell-code}\nrev(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 1 3 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n1 %in% a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n9 %in% a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Statistische Funktionen für Vektoren\n\n| Funktion                             | Beschreibung                         |\n|--------------------------------------|--------------------------------------|\n| `min(x)`, `max(x)`                   | Kleinster und größter Wert           |\n| `mean(x)`                            | Mittelwert                           |\n| `var(x)`                             | Varianz                              |\n| `sd(x)`                              | Standardabweichung                   |\n| `cor(x, y)`                          | Korrelationskoeffizient              |\n| `quantile(x, probs = c(q1, q2, ...)` | Quantilwerte                         |\n| `summary(x)`                         | Gibt Fünf-Punkte-Zusammenfassung aus |\n\n: {tbl-colwidths=\"[50,50]\"}\n\nZum Beispiel\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary((0:100)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      0     625    2500    3350    5625   10000 \n```\n\n\n:::\n:::\n\n\n## Korrelationskoeffizient\n\nZu Fuß\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- x + 0.5 * x^2\nn <- length(x)\nxmid <- 1 / n * sum(x)\nymid <- 1 / n * sum(y)\nsum((x - xmid) * (y - ymid)) / sqrt(sum((x - xmid)^2) * sum((y - ymid)^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9815865\n```\n\n\n:::\n:::\n\n\nMit R-Funktion\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9815865\n```\n\n\n:::\n:::\n\n\n## Benannte Vektoren\n\nDie Einträge von Vektoren können benannt werden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstundenlohn <- c(\"Kellner:in\" = 8.5, \"Ingenieur:in\" = 50)\nstundenlohn\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Kellner:in Ingenieur:in \n         8.5         50.0 \n```\n\n\n:::\n\n```{.r .cell-code}\nstundenlohn[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKellner:in \n       8.5 \n```\n\n\n:::\n\n```{.r .cell-code}\nstundenlohn[\"Kellner:in\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKellner:in \n       8.5 \n```\n\n\n:::\n\n```{.r .cell-code}\nmean(stundenlohn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 29.25\n```\n\n\n:::\n:::\n\n\n→ Anwendung: Zum Beispiel bei Farbskala\n\n## Dataframes\n\n## Dataframe erzeugen mit `tibble()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(\n  X=0:4, \n  Y=c(1.2, 3.2, 0.5, 0.9, 1.1), \n  Z=c(\"A\", \"B\", \"C\", \"D\", \"E\")\n)\n```\n:::\n\n\n- Merkmale und Werte in der Form `Name = Vektor`\n- Wir lesen Dataframes in der Regel aus Dateien (Excel, CSV, etc.)\n- `tibble()` aus tidyverse von Hadley Wickham\n\n## Dataframe ausgeben\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n      X     Y Z    \n  <int> <dbl> <chr>\n1     0   1.2 A    \n2     1   3.2 B    \n3     2   0.5 C    \n4     3   0.9 D    \n5     4   1.1 E    \n```\n\n\n:::\n:::\n\n:::\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [5 × 3] (S3: tbl_df/tbl/data.frame)\n $ X: int [1:5] 0 1 2 3 4\n $ Y: num [1:5] 1.2 3.2 0.5 0.9 1.1\n $ Z: chr [1:5] \"A\" \"B\" \"C\" \"D\" ...\n```\n\n\n:::\n:::\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(d)\n```\n\n::: {.cell-output-display}\n\n\n|  X|   Y|Z  |\n|--:|---:|:--|\n|  0| 1.2|A  |\n|  1| 3.2|B  |\n|  2| 0.5|C  |\n|  3| 0.9|D  |\n|  4| 1.1|E  |\n\n\n:::\n:::\n\n\n## Auf Spalten zugreifen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd$X\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nd$Z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n```\n\n\n:::\n\n```{.r .cell-code}\nd$Z[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"D\"\n```\n\n\n:::\n:::\n\n\n[]{.down20}\n\n- `d$X` liefert die Werte zum Merkmal `X` als Vektor\n- Auf einzelne Werte kann dann mit `[idx]` zugegriffen werden\n- idx wie Index\n- Indizierung beginnt bei 1\n\n## Beispiel: Regressionsgerade/Bestimmtheitsmaß\n\n[]{.down40}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxmid <- mean(d$X)\nymid <- mean(d$Y)\nbeta <- sum((d$X - xmid) * (d$Y - ymid)) / sum((d$X - xmid)^2)\nalpha <- ymid - beta * xmid\nR2 <- sum((alpha + beta * d$X - ymid)^2) / sum((d$Y - ymid)^2)\npaste0(\"alpha = \", alpha, \", beta = \", beta, \", R2 = \", signif(R2, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"alpha = 1.88, beta = -0.25, R2 = 0.14115\"\n```\n\n\n:::\n:::\n\n\n## Hinweis: Geht auch kürzer\n\n[]{.down40}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- lm(Y ~ X, data = d)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Y ~ X, data = d)\n\nResiduals:\n    1     2     3     4     5 \n-0.68  1.57 -0.88 -0.23  0.22 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)   1.8800     0.8721   2.156    0.120\nX            -0.2500     0.3560  -0.702    0.533\n\nResidual standard error: 1.126 on 3 degrees of freedom\nMultiple R-squared:  0.1411,\tAdjusted R-squared:  -0.1451 \nF-statistic: 0.493 on 1 and 3 DF,  p-value: 0.5332\n```\n\n\n:::\n:::\n\n\n# Datum und Uhrzeit\n\nKomplizierter als man auf den ersten Blick vielleicht denkt\n\n- Wie addieren Sie einen Tag zu einer Woche?\n- Hat jedes Jahr 365 Tage?\n- Hat jeder Tag 24 Stunden?\n- An welchem Wochentag sind Sie geboren?\n\nEinfach(er) mit dem lubridate-Paket (zu Beginn laden)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  library(lubridate)\n```\n:::\n\n\n## Date, Time und Date-Time\n\n![Datum und Uhrzeit](bilder/datum-und-uhrzeit.svg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow()                # date-time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-10-06 16:52:32 CEST\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntoday()              # date\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-10-06\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhms::as_hms(now())   # time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n16:52:32.39337\n```\n\n\n:::\n:::\n\n\n## *Date* mit `ymd` und Varianten\n\n::: {.columns}\n::: {.column width=40%}\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"2016-11-30\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2016-11-30\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy(\"30 8 2012\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2012-08-30\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy(\"8/1/1998\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1998-08-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy(30052015)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2015-05-30\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=60%}\n- Liest Datum aus Zeichenkette (Trennzeichen fast beliebig) oder\nZahl \n- Wenn Zahl: Mit 0X angeben, falls X \\< 10 - `ymd`, `dmy` oder `mdy` je nach Reihenfolge\n- In Deutschland meistens Tag/Monat/Jahr \n- Tipp beim Ausprobieren: Tag \\> 12 verwenden um Fehler zu\nfinden \n- Ausgabe in Schreibweise JJJJ-MM-TT\n:::\n:::\n\n## *Date-time* mit `ymd_hms` und Varianten\n\n::: {.columns}\n::: {.column width=60%}\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2016-11-30 10:30:10\", tz = \"Europe/Berlin\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2016-11-30 10:30:10 CET\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy_hm(\"30 8 2012 12:59\", tz = \"Europe/Berlin\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2012-08-30 12:59:00 CEST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy_h(0226201304, tz = \"Europe/Berlin\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2013-02-26 04:00:00 CET\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=40%}\n- Liest Datum und Uhrzeit aus Zeichenkette (Trennzeichen fast beliebig) oder Zahl\n- Wenn Zahl: Mit 0X angeben, falls X \\< 10\n- Wieder je nach Reihenfolge\n- Zeitzone mit angeben (Voreinstellung ist UTC)\n:::\n:::\n\n\n\n## *Time* mit `hms::as.hms` und Varianten\n::: {.columns}\n::: {.column width=60%}\n\n::: {.cell}\n\n```{.r .cell-code}\nhms::as.hms(85)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `as.hms()` was deprecated in hms 0.5.0.\nℹ Please use `as_hms()` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n00:01:25\n```\n\n\n:::\n\n```{.r .cell-code}\nhms::as.hms(dmy_hms(\"1:6:1987 13:17:01\", tz = \"Europe/Berlin\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n13:17:01\n```\n\n\n:::\n\n```{.r .cell-code}\nhms::hms(hours = 1, minutes = 23, seconds = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n01:23:15\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=40%}\n- Zeit, die seit 0 Uhr verstrichen ist\n- Funktion `hms()` aus lubridate-Paket funktioniert nicht beim Plotten\n- Daher `hms::hms()` aus dem Paket hms (ggf. installieren)\n:::\n:::\n\n\n## `make_date()` und `make_datetime()`\n\n[]{.down60}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(year = 2000, month = 10, day = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-10-10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmake_datetime(year = 2000, month = 10, day = 10, hour = 10, tz = \"Europe/Berlin\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-10-10 10:00:00 CEST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmake_datetime(year = 2000, month = 10, day = 10, hour = 10, tz = \"Europe/Berlin\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-10-10 10:00:00 CEST\"\n```\n\n\n:::\n:::\n\n\n## Datumskomponenten: Jahr und Monat\n::: {.columns}\n::: {.column width=60%}\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- dmy_hms(\"15.04.2025 12:22:01\")) # Zuweisung in Klammern: Wert wird ausgegeben\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-04-15 12:22:01 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nyear(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2025\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(d, label = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Apr\n12 Levels: Jan < Feb < Mrz < Apr < Mai < Jun < Jul < Aug < Sep < ... < Dez\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=40%}\n- Namen des Monats mit `label = TRUE`\n- Levels: Richtige Sortierung (nicht alphabetisch)\n:::\n:::\n\n\n\n\n\n## Datumskomponenten: Tag\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nday(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nyday(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 105\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(d, label = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Di\nLevels: So < Mo < Di < Mi < Do < Fr < Sa\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=50%}\n- day = Wievielter Tag im Monat\n- yday = Wievielter Tag im Jahr\n- wday = Wievielter Tag in der Woche (Sonntag = 1)\n- Namen des Tages mit `label = TRUE`\n- Hängt von Ländereinstellung des Computers ab\n:::\n:::\n\n\n\n\n\n## Zeitdifferenzen 1/2\n\nAlter von Friedrich Merz in Tagen am Tag 2025-10-06\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday() - dmy(\"11.11.1955\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 25532 days\n```\n\n\n:::\n:::\n\n\n[]{.down60}\n\nZeit zwischen zwei Anweisungen: Wie lange braucht die Berechnung einer Wurzel?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- hms::as.hms(now())\nx <- sqrt(93482756)\nd2 <- hms::as.hms(now())\nd2 - d1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.001554012 secs\n```\n\n\n:::\n:::\n\n\n## Zeitdifferenzen 2/2\n\n[]{.up10}\n\nEnde März um halb drei\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- dmy_hm(\"30.3.2019 14:30\", tz = \"Europe/Berlin\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2019-03-30 14:30:00 CET\"\n```\n\n\n:::\n:::\n\n\n[]{.down60}\n\n::: {.columns}\n::: {.column width=50%}\n23 Stunden später\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd + dhours(23)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2019-03-31 14:30:00 CEST\"\n```\n\n\n:::\n:::\n\n\n- `dhours()`: Zeitdauer in physikalischen Stunden\n\n:::\n::: {.column width=50%}\nAuch 23 Stunden später\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd + hours(23)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2019-03-31 13:30:00 CEST\"\n```\n\n\n:::\n:::\n\n\n- `hours()`: Zeitdauer in Stunden auf der Uhr\n\n:::\n:::\n\n$\\rightarrow$ Vergleichen Sie die Zeiten!\n\n# 'Normal' rechnen mit Datum/Zeit\n\n## In Zahl konvertieren mit `as.numeric()`\n\n::: {.columns}\n::: {.column width=50%}\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(ymd_hms(\"1970-1-1 0:0:11\", tz = \"UTC\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(ymd(\"1970-1-12\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(hms::as.hms(ymd_hms(\"1988-11-11 0:0:11\", tz=\"Europe/Berlin\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=50%}\nWelche Zahlen kommen dabei heraus?\n\n- Date-time: Sekunden seit Beginn des Jahres 1970 (in UTC)\n- Date: Tage seit Beginn des Jahres 1970\n- Time: Sekunden seit Beginn des Tages\n- 01.01.1970 00:00 Uhr entspricht dem \"absoluten Nullpunkt\" für die Zeitberechnung\n:::\n:::\n\n\n\n\n\n## 'Normal' rechnen mit Zeitdifferenzen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- hms::as.hms(now())\nd2 <- hms::as.hms(now())\nd2 - d1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.001302004 secs\n```\n\n\n:::\n:::\n\n\n[]{.down60}\n\n- Das Ergebnis ist vom Typ 'Time Difference' und keine Zahl\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1000 * as.numeric(d2 - d1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.302004\n```\n\n\n:::\n:::\n\n\n- Mit `as.numeric()` in Zahl konvertieren\n- Ausgabe jetzt in Millisekunden\n\n## Datum runden {.smaller}\n\n![](bilder/datum-runden.svg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfloor_date(d, unit = \"hour\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2019-03-30 14:00:00 CET\"\n```\n\n\n:::\n\n```{.r .cell-code}\nceiling_date(d, unit = \"5 minutes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2019-03-30 14:30:00 CET\"\n```\n\n\n:::\n:::\n\n\n- `floor_date()` : Abrunden\n- `round_date()` : Runden\n- `ceil_date()` : Aufrunden\n- Einheit, zu der gerundet werden soll, mit `unit = XXX` angeben\n- Man kann auch zu einem Vielfachen einer Einheit runden\n\n## Formatierte Ausgabe mit `sprintf()`\n\nMit `sprintf` können Ausgaben ein bisschen schicker gestaltet werden. Dabei steht `%i` für eine\nganze Zahl und `%5.3f` eine Fließkommazahl insgesamt fünf Zeichen breit mit 3 Nachkommastellen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1 / 3\n\nsprintf(\"%i Hallo! x = %5.3f\", 45, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"45 Hallo! x = 0.333\"\n```\n\n\n:::\n:::\n\n\nDen Wert von Variablen kann man auch in den Text einbauen. Hier ein Beispiel\n\n$$1 / 3 \\approx 0.3333333$$\n\nmit einer Variablen in einer Formel.\n\n## Das waren die Basics von R\n\nAuswahl der Themen\n\n- Sehr stark eingeschränkt\n- Nur das absolut Notwendige (subjektive Auswahl)\n\nNicht behandelt\n\n- Kontrollstrukturen: Schleifen und Verzweigungen\n    - Für unsere Zwecke nicht notwendig\n    - Es gibt elegantere Alternativen\n- Eigene Funktionen erstellen\n    - Wir schaffen das (erstmal ohne)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}